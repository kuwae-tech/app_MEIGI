name: build

on:
  push:
    branches:
      - main
      - "codex/**"
      - "feature/**"
      - "fix/**"
  pull_request:
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: build-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ensure-lockfile:
    name: ensure-lockfile
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (branch head)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref || github.ref_name }}

      - name: Setup Node (no cache; lockfile may be missing)
        uses: actions/setup-node@v4
        with:
          node-version: "20.19.6"

      - name: Show versions
        run: |
          node -v
          npm -v
          git --version

      - name: Detect lockfile presence
        id: lf
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Try npm ci (detect broken lockfile)
        id: ci_try
        if: steps.lf.outputs.has == 'true'
        continue-on-error: true
        shell: bash
        run: |
          npm ci --ignore-scripts --no-audit --no-fund

      - name: Generate/repair lockfile when needed
        id: gen
        shell: bash
        run: |
          set -e
          NEED=0
          if [ "${{ steps.lf.outputs.has }}" != "true" ]; then
            echo "[lockfile] missing -> will generate"
            NEED=1
          elif [ "${{ steps.ci_try.outcome }}" != "success" ]; then
            echo "[lockfile] npm ci failed -> will regenerate"
            NEED=1
          else
            echo "[lockfile] looks OK"
          fi

          if [ "$NEED" -eq 1 ]; then
            # generate lockfile deterministically (no scripts)
            npm install --package-lock-only --ignore-scripts --no-audit --no-fund
          fi

          echo "need=$NEED" >> "$GITHUB_OUTPUT"

      - name: Commit & push lockfile if changed
        id: push
        if: steps.gen.outputs.need == '1'
        shell: bash
        run: |
          set -e
          if [ -z "$(git status --porcelain)" ]; then
            echo "[lockfile] no changes after generation"
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "[lockfile] changes detected -> committing"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package-lock.json
          git commit -m "chore(ci): generate/repair package-lock.json"

          BR="${{ github.head_ref || github.ref_name }}"

          # For pull_request from forks, pushing will fail. Detect and stop with a clear message.
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.head.repo.full_name }}" != "${{ github.repository }}" ]; then
            echo "::error::This PR is from a fork. Please commit package-lock.json in the PR branch manually."
            exit 1
          fi

          git push origin "HEAD:$BR"
          echo "changed=true" >> "$GITHUB_OUTPUT"

      - name: Stop here if lockfile was pushed (rerun required)
        if: steps.push.outputs.changed == 'true'
        shell: bash
        run: |
          echo "::error::package-lock.json was generated/repaired and pushed. Re-run the workflow (next run will use npm ci deterministically)."
          exit 1

  build:
    name: build (${{ matrix.os }})
    needs: ensure-lockfile
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout (branch head)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref || github.ref_name }}

      - name: Detect lockfile presence
        id: lf2
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi

      # IMPORTANT: setup-node cache step must not run when lockfile path is unresolved.
      - name: Setup Node (with cache)
        if: steps.lf2.outputs.has == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20.19.6"
          cache: "npm"
          cache-dependency-path: package-lock.json

      - name: Setup Node (no cache)
        if: steps.lf2.outputs.has != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20.19.6"

      - name: Show versions
        run: |
          node -v
          npm -v

      - name: Ensure lockfile exists
        shell: bash
        run: |
          if [ ! -f package-lock.json ]; then
            echo "::error::package-lock.json is missing. Run ensure-lockfile job (or commit lockfile) first."
            exit 1
          fi

      - name: Install dependencies (deterministic, include dev)
        shell: bash
        run: |
          # Force dev deps install even if NODE_ENV=production is set somewhere
          npm ci --include=dev --no-audit --no-fund

      - name: Sanity check - xlsx must resolve
        shell: bash
        run: |
          node -e "console.log('xlsx resolved to:', require.resolve('xlsx'))"

      - name: Normalize xlsx bundle path for sync script (if needed)
        shell: bash
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          function exists(p){ try { fs.accessSync(p); return true; } catch { return false; } }

          let resolved;
          try {
            resolved = require.resolve('xlsx');
          } catch (e) {
            console.error("[xlsx] require.resolve('xlsx') failed. Ensure xlsx is in dependencies/devDependencies.");
            process.exit(1);
          }

          // module root = .../node_modules/xlsx/...
          const modRoot = path.resolve(resolved, '..', '..');
          const target = path.join(modRoot, 'dist', 'xlsx.full.min.js');

          if (exists(target)) {
            console.log('[xlsx] ok:', target);
            process.exit(0);
          }

          const candidates = [
            path.join(modRoot, 'dist', 'xlsx.full.min.mjs'),
            path.join(modRoot, 'dist', 'xlsx.full.min.cjs'),
            path.join(modRoot, 'dist', 'xlsx.full.js'),
            path.join(modRoot, 'dist', 'xlsx.min.js'),
            path.join(modRoot, 'xlsx.full.min.js'),
            path.join(modRoot, 'xlsx.full.js'),
            path.join(modRoot, 'xlsx.js'),
          ].filter(exists);

          if (candidates.length === 0) {
            console.error('[xlsx] Could not find any bundle candidates under:', modRoot);
            process.exit(1);
          }

          fs.mkdirSync(path.dirname(target), { recursive: true });
          fs.copyFileSync(candidates[0], target);
          console.log('[xlsx] copied:', candidates[0], '->', target);
          NODE

      - name: Build (pre-dist)
        shell: bash
        run: |
          npm run build

      - name: Build distribution
        shell: bash
        run: |
          set -e
          # Prefer dist, fallback to pack if present
          if npm run -s | grep -qE '^[[:space:]]+dist'; then
            npm run dist
          elif npm run -s | grep -qE '^[[:space:]]+pack'; then
            npm run pack
          else
            echo "::error::No dist/pack script found in package.json"
            npm run -s
            exit 1
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ matrix.os }}
          if-no-files-found: warn
          path: |
            dist/**
            release/**
            out/**
            build/**
            **/*.dmg
            **/*.exe
            **/*.msi
            **/*.zip
            **/*.AppImage
